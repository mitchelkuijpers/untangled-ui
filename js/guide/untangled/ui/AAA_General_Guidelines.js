// Compiled by ClojureScript 1.9.473 {}
goog.provide('untangled.ui.AAA_General_Guidelines');
goog.require('cljs.core');
goog.require('devcards.core');
goog.require('untangled.client.cards');
goog.require('om.next');
goog.require('om.dom');
goog.require('untangled.i18n.core');
goog.require('untangled.ui.menu');
goog.require('untangled.client.core');
goog.require('untangled.icons');
goog.require('untangled.ui.calendar');
goog.require('untangled.client.mutations');
devcards.core.register_card.call(null,new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"path","path",-188191168),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"untangled.ui.AAA_General_Guidelines","untangled.ui.AAA_General_Guidelines",-1713944018),new cljs.core.Keyword(null,"card","card",-1430355152)], null),new cljs.core.Keyword(null,"func","func",-238706040),(function (){
return devcards.core.card_base.call(null,new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,"name","name",1843675177),"card",new cljs.core.Keyword(null,"documentation","documentation",1889593999),null,new cljs.core.Keyword(null,"main-obj","main-obj",-1544409742),devcards.core.markdown__GT_react.call(null,"# Untangled UI Component Usage\n\n  There are a few kinds of things in this library:\n\n  - Stateless DOM-rendering functions (`elements` namespace) that take care\n  of CSS concerns.\n  - Stateful components that provide OO-style features (e.g. `calendar`)\n  - Layout functions/macros\n  - State management helpers\n  - Full-stack integrations (image library, persistent forms)\n\n  # Elements\n\n  We term functions that generate DOM as elements. These can have various\n  rendering options, and can accept callbacks. These are typically written\n  as regular functions, and encapsulate the CSS tricks needed to render\n  the element correctly. These are in the `elements` namespace.\n\n  # Stateful Components\n\n  UI components that should work with the support viewer need their state\n  inside of your app state. Such components have their own namespace to make\n  their usage more clear. They typically have the following bits:\n\n  - Constructor functions, typically named after the component (e.g. `dropdown`\n  and `dropdown-item`). These return data structures that can be used\n  directly in InitialAppState of the parent (owning) component.\n  - Mutations, typically using the simplest names possible. These are Om mutations\n  defined with Untangled's `defmutation`. You must be using Untangled's `mutate` multimethod as\n  at least part of your UI parser if you are using these with stock Om Next.\n  - Mutation implementation functions. These end with `-impl`, and are functions\n  on a state map or component map. These are used as the implementation of\n  the internals of a mutation, but are public so you can easily compose them\n  into your own mutations if the need should arise. Typically you can compose\n  mutations together in a single `transact!`, which is preferred.\n  - Functions to get abstract data from the state of a component. You may\n  read the map of a component (it is just a value); however, stateful components\n  often define helpers (like `dropdowns/selected-item`). These make it easier to\n  know you're looking at the state of a component correctly without having\n  to worry that you've misspelled the keyword or otherwise misunderstood the\n  internals of a component.\n  - One or more React factory functions, prefixed with `ui-` to distinguide\n  rendering from construction. It is also common for people to use local bindings\n  for a button using the symbol `button`. This prefixing makes name collisions\n  less likely.\n\n  ## Layout Functions/Macros\n\n  None of these exist yet. More info when we define what this looks like.\n\n  Most likely these will take children, possibly as named parameters, and\n  wrap them in DOM layout.\n\n  For example:\n\n  ```\n  (layout/border-layout\n    :north (dom/div ...)\n    :west (dom/div ...))\n  ```\n\n  ## State Management Helpers\n\n  When writing mutations the typical structure is something like this:\n\n  ```\n  (swap! state (fn [m]\n     (-> m\n        (assoc :boo 1)\n        (update :foo inc)))\n  ```\n\n  We encourage authors to write mutations that leverage a bit more abstraction.\n\n  Writing a helper function like `(close-all-menus [state-map] ...)` can\n  enable this:\n\n  ```\n  (swap! state close-all-menus)\n  ```\n\n  which is much nicer to read and easier to understand. It also lets people combine\n  that operation with their own within a mutation without having to understand\n  the internals of the other component:\n\n  ```\n  (defmutation boo\n    [args]\n    (action [{:keys [state]}]\n       (swap! state (fn [m]\n                      (-> m\n                        close-all-menus\n                        ...)))))\n  ```\n\n  When working on a particular component it is very common to have to combine\n  this with `update-in` and the ident of the component. Stateful components\n  should have an `ident` function in their namespace that will return the proper\n  ident for that component (given an ID). Thus, you might find you'd like\n  to write a component's mutation like this:\n\n  ```\n  (defmutation set-open\n    [id open?]\n    (action [{:keys [state]}]\n      (swap! state update-in (dropdown/ident id) set-open-impl open?)))\n  ```\n\n  Since this is a very common pattern we've defined some functions in the\n  `untangled.ui.state` namespace called `evolve` and `evolve!` that make this\n  a bit more concise:\n\n  ```\n  (defmutation set-open\n    [{:keys [id open?]}]\n    (action [{:keys [state]}] (evolve! state (ident id) set-open-impl open?)))\n  ```\n\n  `evolve` takes a map and returns a map (is composable in a single swap), whereas\n  `evolve!` does the swap for you. See the `dropdowns` namespace for a more complete\n  example.\n\n  # Full-Stack Integrations\n\n  This library has components that interact with the server. Two notable examples\n  are an image library and entity-based forms support. The full-stack\n  integrations include pluggable support for almost anything you'd want to\n  customize (for example, image storage mechanism and entity persistence)\n  See the documentation for more details.\n\n  "),new cljs.core.Keyword(null,"initial-data","initial-data",-1315709804),cljs.core.PersistentArrayMap.EMPTY,new cljs.core.Keyword(null,"options","options",99638489),cljs.core.merge.call(null,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"heading","heading",-1312171873),false], null),devcards.core.assert_options_map.call(null,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"hide-border","hide-border",1463657151),true], null)))], null));
})], null));

//# sourceMappingURL=AAA_General_Guidelines.js.map?rel=1489703354207