// Compiled by ClojureScript 1.9.473 {:static-fns true, :optimize-constants true}
goog.provide('untangled.ui.Forms__02_State_Lifecycle');
goog.require('cljs.core');
goog.require('cljs.core.constants');
goog.require('clojure.string');
goog.require('com.stuartsierra.component');
goog.require('untangled.client.cards');
goog.require('devcards.core');
goog.require('om.dom');
goog.require('om.next');
goog.require('untangled.client.core');
goog.require('untangled.client.mutations');
goog.require('untangled.ui.forms');
goog.require('untangled.i18n');
devcards.core.register_card(new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$path,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$untangled$ui$Forms__02_State_Lifecycle,cljs.core.cst$kw$card], null),cljs.core.cst$kw$func,(function (){
return devcards.core.card_base(new cljs.core.PersistentArrayMap(null, 5, [cljs.core.cst$kw$name,"card",cljs.core.cst$kw$documentation,null,cljs.core.cst$kw$main_DASH_obj,devcards.core.markdown__GT_react.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq(["# Form State and Lifecycle\n\n  Form support is meant to track the state of one or more entities through\n  the process of editing. It is important to remember the general\n  model of Om/Untanged is one where the application moves from\n  state to state over time, and the components themselves have (ideally)\n  no local state.\n\n  This means that your form will not change states on you unless a mutation\n  of some sort runs.\n\n  Many of the form fields *do* run mutations on events, which in turn\n  can change the state of the form or the fields.\n\n  A form can have any number of child forms (which themselves can dynamically change\n  over time).\n\n  The lifecycle is as follows:\n\n  ```\n  Regular Persisted Entity <-+\n        |                    |\n        | init-form          |\n        v                    |\n  Pristine Form              |\n        | edits/additions    ^\n        v                   /|\n   Dirty Form -------------/ |\n              reset/commit>  +------+\n                                    |\n  Locally Created (tempid)          |\n        |                           |\n        | init-form                 |\n        v                           | (server tempid remap)\n   Dirty Form                       |\n    ^    |                         _|_\n    |    | edits/additions/reset/commit\n    +----+\n  ```\n\n  ## Is my Form Dirty?\n\n  A form is considered `dirty?` when:\n\n  - Any field of the form or its declared subforms has a value different from\n  the initial (or most recently committed) value.\n  - Any form or subform in a set has an Om tempid (e.g. server remaps have not\n  yet taken effect)\n\n  NOTE: If you're writing forms on a UI that has\n  no server interaction then you will probably want to generate your own\n  numeric unique IDs for any new entities to prevent permanently dirty forms.\n\n  ## Is my Form/Field Valid?\n\n  Form fields that support validation will typically run validation on the field when that\n  field is manipulated. Full-form validation can be done at any time by composing `validate-fields`\n  into your own mutation (see also `on-form-change`). The system is fully flexible, and for the\n  most part validation is composable, extensible, configurable, and happens at Om transaction\n  boundaries in whatever ways you define.\n\n  Validation is tri-state. All fields start out `:unchecked`. If you wish your form to start out\n  `:valid` then you can compose a call to `f/valiate-fields`:\n\n  ```\n  ;; NOTE: non-recursive validation. You'd have to use this explicitly on each declared subform state as well.\n  initial-form (f/validate-fields (f/build-form MyForm my-entity-props))\n  ```\n\n  The functions `valid?` and `invalid?` honor the tri-state nature of forms (e.g. `invalid?` returns\n  true iff at least one field is `:invalid`, and `valid?` returns true iff all fields are\n  `:valid`). The `:unchecked` state thus allows you to prevent error messages from\n  appearing on fields until you're actually ready to validate them:\n\n  ```\n  ;; only emits if the field is actually marked :invalid (not :unchecked)\n  (when (invalid? this-form :field) (dom/span nil \"Invalid!\"))\n\n  ;; Disables submit button unless all fields are marked `:valid` (none are :unchecked or :invalid)\n  (dom/button #js {:disabled (not (valid? form)) :onClick submit} \"Submit!\")\n  ```\n\n  The tricky part is that \"global\" validation is not ever triggered by built-in iteraction\n  support with fields.\n\n  Thus, you have a few ways of dealing with checking if a form is valid:\n\n  1. Trigger a `f/validate-form` mutation. Such a mutation will recursively walk your form and\n  subforms and mark all fields with `:invalid` or `:valid`. This will have the effect of\n  showing validation messages that are defined in the examples above.\n  2. Compose the `f/validate-forms` helper function into your own mutation. This function works against\n  an app state map and recursively updates a form/subforms. (see the source for `defmutation validate-form`)\n  3. Use the `would-be-valid?` function on the forms props (e.g. in the UI). This function returns true\n  if the supplied form (and subforms) would be valid if validation was run on it. It essentially runs\n  validation in a pure functional way.\n\n  If using (1) or (2), then the methods `valid?` and `invalid?` can recursively test the validity. Note that\n  as fields are changed the state of those fields may return to unchecked (which is neither valid or invalid).\n  "], 0)),cljs.core.cst$kw$initial_DASH_data,cljs.core.PersistentArrayMap.EMPTY,cljs.core.cst$kw$options,cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$heading,false], null),devcards.core.assert_options_map(new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$hide_DASH_border,true], null))], 0))], null));
})], null));
